/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MultilingualPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian3 = require("obsidian");

// src/google-translator.ts
var import_obsidian = require("obsidian");

// src/translator.ts
var Translator = class {
  constructor(settings2) {
    this.settings = settings2;
  }
  preCheckErrors(text, targetLanguages, sourceLanguage) {
    if (!navigator.onLine) {
      return "OFFLINE" /* OFFLINE */;
    } else if (!this.settings.apiKeys[this.settings.translationService]) {
      return "AUTH_NO_KEY" /* AUTH_NO_KEY */;
    } else if (targetLanguages.length === 0) {
      return "NO_LANGUAGES" /* NO_LANGUAGES */;
    }
    return void 0;
  }
};

// src/helpers.ts
function decodeHtmlString(text) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(text, "text/html");
  return doc.body.textContent || "";
}
function strFormat(str, ...args) {
  return str.replace(/\${(\d+|[a-zA-Z_]\w*)}/g, (match, group) => {
    if (typeof group === "number") {
      return typeof args[group] !== "undefined" ? args[group] : match;
    } else {
      return typeof args[0][group] !== "undefined" ? args[0][group] : match;
    }
  });
}

// src/google-translator.ts
var GOOGLE_CLOUD_TRANSLATION_URL = "https://translation.googleapis.com/language/translate/v2";
var GoogleTranslator = class extends Translator {
  async translate(text, targetLanguages, sourceLanguage) {
    var _a, _b, _c;
    let result = {};
    let params = new URLSearchParams({
      key: this.settings.apiKeys["Google Translate"],
      q: text,
      source: sourceLanguage || ""
    });
    for (let targetLanguage of targetLanguages) {
      params.set("target", targetLanguage);
      const response = await (0, import_obsidian.requestUrl)({
        url: `${GOOGLE_CLOUD_TRANSLATION_URL}?${params.toString()}`,
        method: "POST",
        throw: false
      });
      if (response.status !== 200) {
        return {
          errorType: this.classifyApiError(response),
          error: response.json.error
        };
      }
      const translations = (_a = response.json.data) == null ? void 0 : _a.translations;
      if (!translations) {
        return { errorType: "OTHER_ERROR" /* OTHER_ERROR */ };
      }
      (_b = result.detectedLanguage) != null ? _b : result.detectedLanguage = translations[0].detectedSourceLanguage;
      ((_c = result.translations) != null ? _c : result.translations = {})[targetLanguage] = translations.map((variant) => decodeHtmlString(variant.translatedText));
    }
    return result;
  }
  classifyApiError(response) {
    var _a, _b, _c, _d;
    if (response.status == 403) {
      return "AUTH_PROBLEM" /* AUTH_PROBLEM */;
    } else if (response.status == 400 && ((_a = response.json.error.message) == null ? void 0 : _a.contains("API key not valid"))) {
      return "AUTH_BAD_KEY" /* AUTH_BAD_KEY */;
    } else if (response.status == 400 && ((_b = response.json.error.message) == null ? void 0 : _b.contains("Invalid Value")) && ((_d = (_c = response.json.error.details[0]) == null ? void 0 : _c.fieldViolations[0]) == null ? void 0 : _d.field) == "target") {
      return "INVALID_LANGUAGES" /* INVALID_LANGUAGES */;
    } else if ([500, 503].includes(response.status)) {
      return "SERVICE_UNAVAILABLE" /* SERVICE_UNAVAILABLE */;
    } else {
      return "OTHER_ERROR" /* OTHER_ERROR */;
    }
  }
};

// src/deepl-translator.ts
var import_obsidian2 = require("obsidian");
var DEEPL_API_URL = "https://api-free.deepl.com/v2/translate";
var DeepLTranslator = class extends Translator {
  async translate(text, targetLanguages, sourceLanguage) {
    var _a, _b;
    let result = {};
    let params = new URLSearchParams({
      auth_key: this.settings.apiKeys["DeepL"],
      text,
      source_lang: sourceLanguage || ""
    });
    for (const targetLanguage of targetLanguages) {
      params.set("target_lang", targetLanguage);
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${DEEPL_API_URL}?${params.toString()}`,
        method: "POST",
        throw: false
      });
      if (response.status !== 200) {
        return {
          errorType: this.classifyApiError(response),
          error: response.text ? response.json.message : void 0
          // sometimes the API seems to reply with just an error code and an empty unparsable message
        };
      }
      const translations = response.json.translations;
      if (!translations) {
        return { errorType: "OTHER_ERROR" /* OTHER_ERROR */ };
      }
      (_a = result.detectedLanguage) != null ? _a : result.detectedLanguage = translations[0].detected_source_language.toLowerCase();
      ((_b = result.translations) != null ? _b : result.translations = {})[targetLanguage] = translations.map((variant) => decodeHtmlString(variant.text));
    }
    return result;
  }
  classifyApiError(response) {
    var _a;
    if (response.status == 403) {
      return "AUTH_PROBLEM" /* AUTH_PROBLEM */;
    } else if (response.status == 400 && ((_a = response.json.message) == null ? void 0 : _a.contains("Value for 'target_lang' not supported."))) {
      return "INVALID_LANGUAGES" /* INVALID_LANGUAGES */;
    } else if ([500, 503].includes(response.status)) {
      return "SERVICE_UNAVAILABLE" /* SERVICE_UNAVAILABLE */;
    } else {
      return "OTHER_ERROR" /* OTHER_ERROR */;
    }
  }
};

// src/settings.ts
var translatorsMap = {
  "Google Translate": GoogleTranslator,
  "DeepL": DeepLTranslator
};
var DEFAULT_SETTINGS = {
  targetLanguages: [],
  autoTranslate: true,
  ignoreDateFormat: "",
  ignoreRegex: "",
  ignorePath: "",
  addOriginalName: false,
  translationService: "Google Translate",
  apiKeys: {
    "Google Translate": "",
    "DeepL": ""
  },
  // not controlled by user:
  setupComplete: false
};
var MultilingualSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName(this.plugin.strings.settings.TARGET_LANGS_FIELD_NAME).setDesc(createFragment((desc) => {
      desc.append(this.plugin.strings.settings.TARGET_LANGS_FIELD_DESC);
      desc.createEl("br");
      desc.append("Available languages: ");
      desc.createEl("a", { "text": "Google Translate", "href": "https://cloud.google.com/translate/docs/languages" });
      desc.append(" / ");
      desc.createEl("a", { "text": "DeepL", "href": "https://www.deepl.com/docs-api/translate-text/translate-text" });
    })).addText((text) => text.setPlaceholder("fr, it, ...").setValue(this.plugin.settings.targetLanguages.join(", ")).onChange(async (value) => {
      this.plugin.settings.targetLanguages = value ? value.split(",").map((lang) => lang.trim()) : [];
      this.checkSetupComplete();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(this.plugin.strings.settings.AUTO_TRANSLATE_TOGGLE_NAME).setDesc(this.plugin.strings.settings.AUTO_TRANSLATE_TOGGLE_DESC).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoTranslate).onChange((value) => {
      this.plugin.settings.autoTranslate = value;
      ignoreDateFormatField.setDisabled(!value);
      ignoreRegexField.setDisabled(!value);
      ignorePathField.setDisabled(!value);
      this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName(this.plugin.strings.settings.TRANSLATOR_SELECTOR_NAME).setDesc(this.plugin.strings.settings.TRANSLATOR_SELECTOR_DESC).addDropdown((dropdown) => dropdown.addOption("Google Translate", "Google Translate").addOption("DeepL", "DeepL").setValue(this.plugin.settings.translationService).onChange(async (value) => {
      this.plugin.settings.translationService = value;
      this.plugin.loadTranslator();
      this.updateApiKeySetting(apiKeySetting);
      await this.plugin.saveSettings();
    }));
    let apiKeySetting = new import_obsidian3.Setting(containerEl);
    this.updateApiKeySetting(apiKeySetting);
    new import_obsidian3.Setting(containerEl).setName(this.plugin.strings.settings.H3_ADVANCED).setHeading();
    new import_obsidian3.Setting(containerEl).setName(this.plugin.strings.settings.ADD_ORIGINAL_NAME_NAME).setDesc(this.plugin.strings.settings.ADD_ORIGINAL_NAME_DESC).addToggle((toggle) => toggle.setValue(this.plugin.settings.addOriginalName).onChange((value) => {
      this.plugin.settings.addOriginalName = value;
      this.plugin.saveSettings();
    }));
    const ignoreDateFormatField = new import_obsidian3.Setting(containerEl).setName(this.plugin.strings.settings.IGNORE_DATE_FORMAT_FIELD_NAME).setDesc(this.plugin.strings.settings.IGNORE_DATE_FORMAT_FIELD_DESC).addText((text) => text.setDisabled(!this.plugin.settings.autoTranslate).setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.ignoreDateFormat).onChange((value) => {
      this.plugin.settings.ignoreDateFormat = value;
      this.plugin.saveSettings();
    }));
    const ignoreRegexField = new import_obsidian3.Setting(containerEl).setName(this.plugin.strings.settings.IGNORE_REGEX_FIELD_NAME).setDesc(this.plugin.strings.settings.IGNORE_REGEX_FIELD_DESC).addText((text) => text.setDisabled(!this.plugin.settings.autoTranslate).setPlaceholder("^_^regex...").setValue(this.plugin.settings.ignoreRegex).onChange((value) => {
      this.plugin.settings.ignoreRegex = value;
      this.plugin.saveSettings();
    }));
    const ignorePathField = new import_obsidian3.Setting(containerEl).setName(this.plugin.strings.settings.IGNORE_PATH_FIELD_NAME).setDesc(this.plugin.strings.settings.IGNORE_PATH_FIELD_DESC).addText((text) => text.setPlaceholder(this.plugin.strings.settings.IGNORE_PATH_FIELD_PLACEHOLDER).setValue(this.plugin.settings.ignorePath).onChange((value) => {
      this.plugin.settings.ignorePath = value;
      this.plugin.saveSettings();
    }));
  }
  // Updates the api key field in the setting to reflect the chosen translator
  updateApiKeySetting(apiKeySetting) {
    apiKeySetting.clear().setName(strFormat(this.plugin.strings.settings.API_KEY_FIELD_NAME, { translator: this.plugin.settings.translationService })).setDesc(strFormat(this.plugin.strings.settings.API_KEY_FIELD_DESC, { translator: this.plugin.settings.translationService })).addText((text) => text.setPlaceholder(this.plugin.settings.apiKeys ? `*** *** *** ${this.plugin.settings.apiKeys[this.plugin.settings.translationService].slice(-4)}` : "YOUR_API_KEY").onChange(async (value) => {
      this.plugin.settings.apiKeys[this.plugin.settings.translationService] = value;
      this.checkSetupComplete();
      await this.plugin.saveSettings();
    }));
  }
  checkSetupComplete() {
    this.plugin.settings.setupComplete = this.plugin.settings.targetLanguages.length > 0 && this.plugin.settings.apiKeys[this.plugin.settings.translationService].length > 0;
  }
};

// src/l10n/elements.ts
var untitled_filename = {
  "af": "Untitled",
  "am": "\u122D\u12D5\u1235 \u12A0\u120D\u1263",
  "ar": "\u0628\u062F\u0648\u0646 \u0639\u0646\u0648\u0627\u0646",
  "az": "Untitled",
  "be": "Untitled",
  "bg": "Untitled",
  "bn": "Untitled",
  "ca": "Sense t\xEDtol",
  "cs": "Bez n\xE1zvu",
  "da": "Unavngivet",
  "de": "Unbenannt",
  "el": "\u03A7\u03C9\u03C1\u03AF\u03C2 \u03A4\u03AF\u03C4\u03BB\u03BF",
  "en": "Untitled",
  "en-GB": "Untitled",
  "eo": "Untitled",
  "es": "Sin t\xEDtulo",
  "eu": "Untitled",
  "fa": "\u0628\u06CC\u200C\u0646\u0627\u0645",
  "fi": "Nimet\xF6n",
  "fr": "Sans titre",
  "gl": "Untitled",
  "he": "Untitled",
  "hi": "Untitled",
  "hr": "Bez naslova",
  "hu": "N\xE9vtelen",
  "id": "Tanpa judul",
  "it": "Senza nome",
  "ja": "\u7121\u984C\u306E\u30D5\u30A1\u30A4\u30EB",
  "ka": "Untitled",
  "kh": "\u1782\u17D2\u1798\u17B6\u1793\u1785\u17C6\u178E\u1784\u1787\u17BE\u1784",
  "kn": "Untitled",
  "ko": "\uBB34\uC81C \uD30C\uC77C",
  "lt": "Untitled",
  "lv": "Untitled",
  "ml": "Untitled",
  "ms": "Tak bertajuk",
  "nan-TW": "Untitled",
  "nl": "Naamloos",
  "nn": "Untitled",
  "no": "Untitled",
  "oc": "Untitled",
  "pl": "Bez nazwy",
  "pt": "Sem t\xEDtulo",
  "pt-BR": "Sem t\xEDtulo",
  "ro": "Untitled",
  "ru": "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F",
  "sa": "\u0905\u0928\u0936\u0940\u0930\u094D\u0937\u0915\u092E\u094D",
  "se": "Untitled",
  "si": "Untitled",
  "sk": "Untitled",
  "sl": "Untitled",
  "sq": "I paem\xEBrtuar",
  "sr": "Untitled",
  "ta": "Untitled",
  "te": "Untitled",
  "th": "\u0E22\u0E31\u0E07\u0E44\u0E21\u0E48\u0E44\u0E14\u0E49\u0E15\u0E31\u0E49\u0E07\u0E0A\u0E37\u0E48\u0E2D",
  "tl": "Untitled",
  "tr": "Ba\u015Fl\u0131ks\u0131z",
  "uk": "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0438",
  "ur": "Untitled",
  "uz": "Untitled",
  "vi": "Ch\u01B0a \u0111\u1EB7t t\xEAn",
  "zh-CN": "\u672A\u547D\u540D",
  "zh-TW": "\u672A\u547D\u540D"
};
var untitledIn = (locale) => {
  var _a;
  return (_a = untitled_filename[locale]) != null ? _a : untitled_filename["en"];
};

// src/l10n/en.json
var en_exports = {};
__export(en_exports, {
  default: () => en_default,
  menus: () => menus,
  notices: () => notices,
  settings: () => settings
});
var notices = {
  success: {
    TRANSLATIONS_ADDED: "(You can edit these aliases in properties)",
    NO_TRANSLATIONS_ADDED: "Name already available in all your languages."
  },
  errors: {
    NOT_A_FILE: "Cannot translate the name of nothing, because nothing doesn't have anything, notably no name."
  },
  translation_errors: {
    OFFLINE: "Name not translated! \u274C You seem to be offline \u{1F3D5}\uFE0F",
    NO_LANGUAGES: "Name not translated! \u274C Please choose at least one language in the plugin settings \u{1F527}",
    INVALID_LANGUAGES: "Name not translated! \u274C One of the languages you requested is not valid, please check in settings \u{1F62C}",
    AUTH_NO_KEY: "Name not translated! \u274C Please provide an API key in Settings \u{1F511}",
    AUTH_BAD_KEY: "Name not translated! \u274C Check your API key, it seems not valid \u{1F511}",
    AUTH_PROBLEM: "Name not translated! \u274C Authentication problem, check your API key \u{1F47E}",
    FREE_LIMITS_REACHED: "Name not translated! \u274C Free usage limits reached, please check you API key account \u{1F631}",
    SERVICE_UNAVAILABLE: "Name not translated! \u274C Service unavailable, try again later \u{1F559}",
    OTHER_ERROR: "Name not translated! \u274C Some weird error during translation \u{1F92F}"
  }
};
var menus = {
  COMMAND_ACTION: "Translate note name",
  RIBBON_ICON_ACTION: "Multilingual note name",
  EDITOR_MENU_ACTION: "Multilingual note name"
};
var settings = {
  TARGET_LANGS_FIELD_NAME: "Your languages",
  TARGET_LANGS_FIELD_DESC: 'Note names will be translated to these languages and added to aliases, so that you can link your notes in all your languages. (e.g.: "fr, it")',
  AUTO_TRANSLATE_TOGGLE_NAME: "Auto translate",
  AUTO_TRANSLATE_TOGGLE_DESC: "Whether to automatically translate the name every time you create or rename a note. (Translation is always available via command, ribbon or right-click menu.)",
  H3_TRANSLATOR: "Translation service",
  TRANSLATOR_SELECTOR_NAME: "Translation service",
  TRANSLATOR_SELECTOR_DESC: "Google Translate supports more languages. DeepL is considered more accurate and natural-sounding, and is easier to set up.",
  API_KEY_FIELD_NAME: "${translator} API key (mandatory)",
  API_KEY_FIELD_DESC: "Paste your ${translator} API key here, this is mandatory for the plugin to work. (The API key is stored somewhere in the config files of your Obsidian vault.)",
  H3_ADVANCED: "Advanced",
  ADD_ORIGINAL_NAME_NAME: "Add original name to aliases",
  ADD_ORIGINAL_NAME_DESC: "This can make inserting links faster for languages with declensions (German, Russian, Latin (oh my), ...), but you may also find other use cases.",
  IGNORE_DATE_FORMAT_FIELD_NAME: "Date format to ignore",
  IGNORE_DATE_FORMAT_FIELD_DESC: "Names matching this date format won't be auto-translated. Can be useful for for daily notes. Default: YYYY-MM-DD.",
  IGNORE_REGEX_FIELD_NAME: "Custom regex to ignore",
  IGNORE_REGEX_FIELD_DESC: "Names matching this custom regex won't be auto-translated.",
  IGNORE_PATH_FIELD_NAME: "Custom path to ignore",
  IGNORE_PATH_FIELD_DESC: "Names of notes in this folder and its subfolders won't be auto-translated.",
  IGNORE_PATH_FIELD_PLACEHOLDER: "e.g.: NASA/Apollo 15/LRV"
};
var en_default = {
  notices,
  menus,
  settings
};

// src/main.ts
var MultilingualPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.loadLocale();
    this.loadTranslator();
    this.addSettingTab(new MultilingualSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      this.registerEvent(
        this.app.vault.on("create", (file) => {
          if (this.settings.autoTranslate) {
            this.autoTranslateName(file);
          }
        })
      );
    });
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (this.settings.autoTranslate && !oldPath.includes(file.name)) {
          this.autoTranslateName(file);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (view.file) {
          let file = view.file;
          menu.addItem((item) => {
            item.setTitle(this.strings.menus.EDITOR_MENU_ACTION).setIcon("languages").onClick(() => {
              this.translateName(file);
            });
          });
        }
      })
    );
    this.addCommand({
      id: "translate-name",
      name: this.strings.menus.COMMAND_ACTION,
      editorCallback: (editor, view) => {
        if (view.file) {
          this.translateName(view.file);
        } else {
          new import_obsidian4.Notice(this.strings.notices.errors.NOT_A_FILE);
        }
      }
    });
    this.addRibbonIcon("languages", this.strings.menus.RIBBON_ICON_ACTION, (evt) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      if (view && view.file) {
        this.translateName(view.file);
      } else {
      }
    });
  }
  onunload() {
  }
  isToBeAutoTranslated(name, path) {
    const matchesPathToIgnore = !!this.settings.ignorePath && path.startsWith(this.settings.ignorePath);
    const isNumbersOnly = /^[0-9\.\,\'\+\-\_\&\@\%\~\$\(\) ]+$/.test(name);
    const isUntitled = new RegExp(`^${untitledIn(this.locale)}(?:\\s\\d+)?$`).test(name);
    const matchesDatesToIgnore = !!this.settings.ignoreDateFormat && (0, import_obsidian4.moment)(name, this.settings.ignoreDateFormat, true).isValid();
    const matchesRegexToIgnore = !!this.settings.ignoreRegex && new RegExp(this.settings.ignoreRegex).test(name);
    return !(matchesPathToIgnore || isNumbersOnly || isUntitled || matchesDatesToIgnore || matchesRegexToIgnore);
  }
  async autoTranslateName(file) {
    if (this.isToBeAutoTranslated(file.basename, file.path) && this.settings.setupComplete) {
      this.translateName(file);
    }
  }
  async translateName(file) {
    let preCheckError = this.translator.preCheckErrors(file.basename, this.settings.targetLanguages);
    if (preCheckError) {
      new import_obsidian4.Notice(this.strings.notices.translation_errors[preCheckError]);
      return;
    }
    let translationsResult;
    try {
      translationsResult = await this.translator.translate(file.basename, this.settings.targetLanguages);
    } catch (error) {
      new import_obsidian4.Notice(this.strings.notices.translation_errors.OTHER_ERROR);
      console.error("Unrecognised error during translation: " + error);
      return;
    }
    if (translationsResult.errorType) {
      new import_obsidian4.Notice(this.strings.notices.translation_errors[translationsResult.errorType]);
      if (translationsResult.error) {
        console.error("Error during translation: ", translationsResult.error);
      }
      return;
    }
    let translationsToAdd = Object.entries(translationsResult.translations || {}).filter(([langCode]) => langCode !== translationsResult.detectedLanguage).map(([, variants]) => variants[0]);
    this.addAliases(file, translationsToAdd, this.settings.addOriginalName);
  }
  async addAliases(file, aliases, includeName = false) {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (typeof frontmatter == "object") {
        if (includeName) {
          aliases.push(file.basename);
        } else {
          aliases.remove(file.basename);
        }
        const currentAliases = frontmatter.aliases || [];
        const newAliases = [...new Set(currentAliases.concat(aliases))];
        if (newAliases.length > currentAliases.length) {
          frontmatter.aliases = newAliases;
          new import_obsidian4.Notice(`${[...new Set(aliases)].join("\n")}

${this.strings.notices.success.TRANSLATIONS_ADDED}`);
        } else {
          new import_obsidian4.Notice(this.strings.notices.success.NO_TRANSLATIONS_ADDED);
        }
      }
    });
  }
  // gets user's locale (Obsidian display language) to adapt some of the plugin's functionality to it
  loadLocale() {
    this.locale = import_obsidian4.moment.locale();
    this.strings = en_exports;
  }
  // instanciates a Translator, based on the settings
  loadTranslator() {
    this.translator = new translatorsMap[this.settings.translationService](this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};


/* nosourcemap */